import pefile
import os
import array
import math
import pickle
import joblib
import sys
from threading import *
from tkinter import *
from tkinter.filedialog import askopenfilename
import tkinter, tkinter.scrolledtext
import sys
import urllib.request
import glob
import time
import hashlib
import quarantaene

os_name = sys.platform
terminations = []

if "win" in os_name:
    if not os.path.exists("MLAnti\\Quarantine\\"):
        os.makedirs("MLAnti\\Quarantine\\")
    quarantine_folder = "MLAnti\\Quarantine\\*"
    file_to_quarantine = "MLAnti\\Quarantine\\"
    transfer = os. getcwd() + "\\Transfer\\*"
    classifier = os.getcwd() + "\\Classifier"
else:
    if not os.path.exists("MLAnti/Quarantine/"):
        os.makedirs("MLAnti/Quarantine/")
    quarantine_folder = "MLAnti/Quarantine/*"
    file_to_quarantine = "MLAnti/Quarantine/"
    transfer = os. getcwd() + "/Transfer/*"
    classifier = os.getcwd() + "/Classifier"

main = None
update_button = None
scan_button = None
quit_button = None
b_delete = None
b_delete_all = None
b_restore = None
b_restore_all = None
b_add_file = None
text_box = None
li = None
file= None

def get_entropy(data):
    """Get entropy of file"""
    if len(data) == 0:
        return 0.0
    occurences = array.array('L', [0] * 256)
    for x in data:
        occurences[x if isinstance(x, int) else ord(x)] += 1

    entropy = 0
    for x in occurences:
        if x:
            p_x = float(x) / len(data)
            entropy -= p_x * math.log(p_x, 2)

    return entropy


def get_resources(pe):
    """Extract resources: [entropy, size]"""
    resources = []
    if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
        try:
            for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                if hasattr(resource_type, 'directory'):
                    for resource_id in resource_type.directory.entries:
                        if hasattr(resource_id, 'directory'):
                            for resource_lang in resource_id.directory.entries:
                                data = pe.get_data(
                                    resource_lang.data.struct.OffsetToData, resource_lang.data.struct.Size)
                                size = resource_lang.data.struct.Size
                                entropy = get_entropy(data)

                                resources.append([entropy, size])
        except Exception:
            return resources
    return resources


def get_version_info(pe):
    """Return version information"""
    res = {}
    for fileinfo in pe.FileInfo:
        if fileinfo.Key == 'StringFileInfo':
            for st in fileinfo.StringTable:
                for entry in st.entries.items():
                    res[entry[0]] = entry[1]
        if fileinfo.Key == 'VarFileInfo':
            for var in fileinfo.Var:
                res[var.entry.items()[0][0]] = var.entry.items()[0][1]
    if hasattr(pe, 'VS_FIXEDFILEINFO'):
        res['flags'] = pe.VS_FIXEDFILEINFO.FileFlags
        res['os'] = pe.VS_FIXEDFILEINFO.FileOS
        res['type'] = pe.VS_FIXEDFILEINFO.FileType
        res['file_version'] = pe.VS_FIXEDFILEINFO.FileVersionLS
        res['product_version'] = pe.VS_FIXEDFILEINFO.ProductVersionLS
        res['signature'] = pe.VS_FIXEDFILEINFO.Signature
        res['struct_version'] = pe.VS_FIXEDFILEINFO.StrucVersion
    return res


def extract_infos(fpath):
    """Extract information about file"""
    try:
        pe = pefile.PE(fpath)
    except pefile.PEFormatError:
        return {}

    res = {}
    res['Machine'] = pe.FILE_HEADER.Machine
    res['SizeOfOptionalHeader'] = pe.FILE_HEADER.SizeOfOptionalHeader
    res['Characteristics'] = pe.FILE_HEADER.Characteristics
    res['MajorLinkerVersion'] = pe.OPTIONAL_HEADER.MajorLinkerVersion
    res['MinorLinkerVersion'] = pe.OPTIONAL_HEADER.MinorLinkerVersion
    res['SizeOfCode'] = pe.OPTIONAL_HEADER.SizeOfCode
    res['SizeOfInitializedData'] = pe.OPTIONAL_HEADER.SizeOfInitializedData
    res['SizeOfUninitializedData'] = pe.OPTIONAL_HEADER.SizeOfUninitializedData
    res['AddressOfEntryPoint'] = pe.OPTIONAL_HEADER.AddressOfEntryPoint
    res['BaseOfCode'] = pe.OPTIONAL_HEADER.BaseOfCode
    try:
        res['BaseOfData'] = pe.OPTIONAL_HEADER.BaseOfData
    except AttributeError:
        res['BaseOfData'] = 0
    res['ImageBase'] = pe.OPTIONAL_HEADER.ImageBase
    res['SectionAlignment'] = pe.OPTIONAL_HEADER.SectionAlignment
    res['FileAlignment'] = pe.OPTIONAL_HEADER.FileAlignment
    res['MajorOperatingSystemVersion'] = pe.OPTIONAL_HEADER.MajorOperatingSystemVersion
    res['MinorOperatingSystemVersion'] = pe.OPTIONAL_HEADER.MinorOperatingSystemVersion
    res['MajorImageVersion'] = pe.OPTIONAL_HEADER.MajorImageVersion
    res['MinorImageVersion'] = pe.OPTIONAL_HEADER.MinorImageVersion
    res['MajorSubsystemVersion'] = pe.OPTIONAL_HEADER.MajorSubsystemVersion
    res['MinorSubsystemVersion'] = pe.OPTIONAL_HEADER.MinorSubsystemVersion
    res['SizeOfImage'] = pe.OPTIONAL_HEADER.SizeOfImage
    res['SizeOfHeaders'] = pe.OPTIONAL_HEADER.SizeOfHeaders
    res['CheckSum'] = pe.OPTIONAL_HEADER.CheckSum
    res['Subsystem'] = pe.OPTIONAL_HEADER.Subsystem
    res['DllCharacteristics'] = pe.OPTIONAL_HEADER.DllCharacteristics
    res['SizeOfStackReserve'] = pe.OPTIONAL_HEADER.SizeOfStackReserve
    res['SizeOfStackCommit'] = pe.OPTIONAL_HEADER.SizeOfStackCommit
    res['SizeOfHeapReserve'] = pe.OPTIONAL_HEADER.SizeOfHeapReserve
    res['SizeOfHeapCommit'] = pe.OPTIONAL_HEADER.SizeOfHeapCommit
    res['LoaderFlags'] = pe.OPTIONAL_HEADER.LoaderFlags
    res['NumberOfRvaAndSizes'] = pe.OPTIONAL_HEADER.NumberOfRvaAndSizes

    # Sections
    res['SectionsNb'] = len(pe.sections)
    entropy = list(map(lambda x: x.get_entropy(), pe.sections))
    res['SectionsMeanEntropy'] = sum(entropy) / float(len(entropy))
    res['SectionsMinEntropy'] = min(entropy)
    res['SectionsMaxEntropy'] = max(entropy)
    raw_sizes = list(map(lambda x: x.SizeOfRawData, pe.sections))
    res['SectionsMeanRawsize'] = sum(raw_sizes) / float(len(raw_sizes))
    res['SectionsMinRawsize'] = min(raw_sizes)
    res['SectionsMaxRawsize'] = max(raw_sizes)
    virtual_sizes = list(map(lambda x: x.Misc_VirtualSize, pe.sections))
    res['SectionsMeanVirtualsize'] = sum(
        virtual_sizes) / float(len(virtual_sizes))
    res['SectionsMinVirtualsize'] = min(virtual_sizes)
    res['SectionMaxVirtualsize'] = max(virtual_sizes)

    # Imports
    try:
        res['ImportsNbDLL'] = len(pe.DIRECTORY_ENTRY_IMPORT)
        imports = sum([x.imports for x in pe.DIRECTORY_ENTRY_IMPORT], [])
        res['ImportsNb'] = len(imports)
        res['ImportsNbOrdinal'] = len(
            list(filter(lambda x: x.name is None, imports)))
    except AttributeError:
        res['ImportsNbDLL'] = 0
        res['ImportsNb'] = 0
        res['ImportsNbOrdinal'] = 0

    # Exports
    try:
        res['ExportNb'] = len(pe.DIRECTORY_ENTRY_EXPORT.symbols)
    except AttributeError:
        # No export
        res['ExportNb'] = 0
    # Resources
    resources = get_resources(pe)
    res['ResourcesNb'] = len(resources)
    if len(resources) > 0:
        entropy = list(map(lambda x: x[0], resources))
        res['ResourcesMeanEntropy'] = sum(entropy) / float(len(entropy))
        res['ResourcesMinEntropy'] = min(entropy)
        res['ResourcesMaxEntropy'] = max(entropy)
        sizes = list(map(lambda x: x[1], resources))
        res['ResourcesMeanSize'] = sum(sizes) / float(len(sizes))
        res['ResourcesMinSize'] = min(sizes)
        res['ResourcesMaxSize'] = max(sizes)
    else:
        res['ResourcesNb'] = 0
        res['ResourcesMeanEntropy'] = 0
        res['ResourcesMinEntropy'] = 0
        res['ResourcesMaxEntropy'] = 0
        res['ResourcesMeanSize'] = 0
        res['ResourcesMinSize'] = 0
        res['ResourcesMaxSize'] = 0

    # Load configuration size
    try:
        res['LoadConfigurationSize'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.Size
    except AttributeError:
        res['LoadConfigurationSize'] = 0

    # Version configuration size
    try:
        version_infos = get_version_info(pe)
        res['VersionInformationSize'] = len(version_infos.keys())
    except AttributeError:
        res['VersionInformationSize'] = 0
    return res

def quarantine():
    global text_box
    global terminations
    global li
    global b_delete
    global b_delete_all
    global b_restore
    global b_restore_all
    global b_add_file
    k = 0
    while True:
        tmp = len(li.get(k))
        if tmp == 0:
            break
        else:
            li.delete(0, tmp)
            k += 1
    li.update()
    terminations = glob.glob(quarantine_folder)
    if terminations == []:
        text_box.insert(END, "[ + ] No files in quarantine\n", "positive")
        text_box.tag_config('positive', foreground="green")
        text_box.see(END)
        text_box.update()
    else:
        text_box.insert(END, "[ + ] Files in quarantine:\n", "positive")
        text_box.tag_config('positive', foreground="green")
        text_box.see(END)
        text_box.update()
        for i in terminations:
            text_box.insert(END, "[ * ] " + i + "\n", "info")
            text_box.tag_config("info", background = "red")
            text_box.see(END)
            text_box.update()
            li.insert(END, i)
            li.update()
    b_delete_all["command"] =lambda:button_action_handler("delete_all")
    b_delete["command"] = lambda:button_action_handler("delete")
    b_restore["command"] = lambda:button_action_handler("restore")
    b_restore_all["command"] = lambda:button_action_handler("restore_all")
    b_add_file["command"] = lambda:button_action_handler("add_file")

def delete(file, ALL):
    global li
    global text_box
    global terminations
    if len(terminations) != 0:
        if ALL == 1:
            for i in range(len(terminations)):
                os.remove(terminations[i])
                text_box.insert(END, "[ + ] Deletion successful: \n" + terminations[i] + "\n", "positive")
                text_box.tag_config("positive", foreground="green")
                text_box.see(END)
                text_box.update()
                li.delete(0, len(terminations[i]))
                li.update()
        elif ALL == 0:
            os.remove(file)
            li.delete(ACTIVE, len(file))
            li.update()
            text_box.insert(END, "[ + ] Deletion successful:\n" + file + "\n", "positive")
            text_box.tag_config("positive", foreground="green")
            text_box.see(END)
            text_box.update()
        terminations = glob.glob(quarantine_folder)
        for i in terminations:
            li.insert(END, i)
        li.update()
    else:
        text_box.insert(END, "[ - ] Unable to locate any files\n", "negative")
        text_box.tag_config("negative", foreground="red")
        text_box.see(END)
        text_box.update()

def restore(file, ALL):
    global li
    global text_box
    global terminations
    if len(terminations) != 0:
        if ALL == 1:
            for i in range(len(terminations)):
                quarantaene.decode_base64(terminations[i])
                text_box.insert(END, "[ + ] Successfully restored\n" + terminations[i] + "\n", 'positive')
                text_box.tag_config('positive', foreground="green")
                text_box.see(END)
                text_box.update()
                li.delete(0, len(terminations[i]))
                li.update()
        elif ALL == 0:
            quarantaene.decode_base64(file)
            li.delete(ACTIVE, len(file))
            text_box.insert(END, "[ + ] Successfully restored\n" + file + "\n", "positive")
            text_box.tag_config("positive", foreground="green")
            text_box.see(END)
            text_box.update()
        terminations = glob.glob(quarantine_folder)
        for i in terminations:
            li.insert(END, i)
        li.update()
    else:
        text_box.insert(END, "[ - ] Unable to locate any files\n", "negative")
        text_box.tag_config("negative", foreground="red")
        text_box.see(END)
        text_box.update()

def add_file_to_quarantine():
    global li
    global terminations
    file = askopenfilename()
    quarantaene.encode_base64(file, file_to_quarantine)
    text_box.insert(END, "[ + ] Moved to quarantine:\n" + file + "\n", "positive")
    text_box.tag_config("positive", foreground="green")
    text_box.see(END)
    text_box.update()
    li.update()
    k = 0
    while True:
        tmp = len(li.get(k))
        if tmp == 0:
            break
        else:
            li.delete(0, tmp)
            k += 1
    li.update()
    terminations = glob.glob(quarantine_folder)
    for i in terminations:
        li.insert(END, i)
        li.update()

def automatic_scan(path):
    global text_box
    global md5hash
    match = False
    file = path
    start = time.time()
    text_box.insert(END, "[ * ] Scanning " + file + "\n")
    text_box.see(END)
    text_box.update()
    clf = joblib.load(os.path.join(classifier,'classifier.pkl'))
    features = pickle.loads(open(os.path.join(classifier,'features.pkl'),'rb').read())
    data = extract_infos(file)
    if(len(list(data))==0):
        text_box.insert(END, "[ * ] Not a PE file. " + "\n")
        text_box.see(END)
        text_box.update()
    else:
        pe_features = list(map(lambda x: data[x], features))
        res = clf.predict([pe_features])[0]
        if(res==0):
            match=True

    try:
        f = open(file, "rb")
        content = f.read()
        f.close()
        content = create_md5(content)
        md5hash=content.decode("utf-8")
        text_box.insert(END, "MD5-Hash: " + md5hash + "\n")
        text_box.see(END)
        text_box.update()

    except MemoryError:
        text_box.insert(END, "[ - ] Unable to create MD5-Hash:\n----->MemoryError!\n", 'negative')
        text_box.insert(END, "[ ! ] Only select files under 1 GB\n", "negative")
        text_box.tag_config('negative', foreground="red")
        text_box.see(END)
        text_box.update()
        return None
    except Exception as e:
        text_box.insert(END, "[ ! ] Unable to handle problem\n[ ! ] Try again/file might be corrupted\n", "negative")
        text_box.tag_config('negative', foreground="red")
        text_box.see(END)
        text_box.update()
        return None

    text_box.insert(END, "[ * ] Scan duration: {0}\n".format(round(time.time()-start, 2)))
    text_box.see(END)
    text_box.update()
    if (match==True):
        quarantaene.encode_base64(file, file_to_quarantine)
        text_box.insert(END, "[ ! ] Threat found\n[ ! ] File was moved into quarantine\n", "important")
        text_box.tag_config("important", foreground="red")
        text_box.see(END)
        text_box.update()
    else:
        text_box.insert(END, "[ + ] No threat was found\n", "positive")
        text_box.tag_config("positive", foreground="green")
        text_box.see(END)
        text_box.update()

def scan():
    global text_box
    global md5hash
    match = False
    file = askopenfilename()
    start = time.time()
    text_box.insert(END, "[ * ] Scanning " + file + "\n")
    text_box.see(END)
    text_box.update()
    clf = joblib.load(os.path.join(classifier,'classifier.pkl'))
    features = pickle.loads(open(os.path.join(classifier,'features.pkl'),'rb').read())
    data = extract_infos(file)
    if(len(list(data))==0):
        text_box.insert(END, "[ * ] Not a PE file. " + "\n")
        text_box.see(END)
        text_box.update()
    else:
        pe_features = list(map(lambda x: data[x], features))
        res = clf.predict([pe_features])[0]
        if(res==0):
            match=True

    try:
        f = open(file, "rb")
        content = f.read()
        f.close()
        content = create_md5(content)
        md5hash=content.decode("utf-8")
        text_box.insert(END, "MD5-Hash: " + md5hash + "\n")
        text_box.see(END)
        text_box.update()

    except MemoryError:
        text_box.insert(END, "[ - ] Unable to create MD5-Hash:\n----->MemoryError!\n", 'negative')
        text_box.insert(END, "[ ! ] Only select files under 1 GB\n", "negative")
        text_box.tag_config('negative', foreground="red")
        text_box.see(END)
        text_box.update()
        return None
    except Exception as e:
        text_box.insert(END, "[ ! ] Unable to handle problem\n[ ! ] Try again/file might be corrupted\n", "negative")
        text_box.tag_config('negative', foreground="red")
        text_box.see(END)
        text_box.update()
        return None

    text_box.insert(END, "[ * ] Scan duration: {0}\n".format(round(time.time()-start, 2)))
    text_box.see(END)
    text_box.update()
    if (match==True):
        quarantaene.encode_base64(file, file_to_quarantine)
        text_box.insert(END, "[ ! ] Threat found\n[ ! ] File was moved into quarantine\n", "important")
        text_box.tag_config("important", foreground="red")
        text_box.see(END)
        text_box.update()
    else:
        text_box.insert(END, "[ + ] No threat was found\n", "positive")
        text_box.tag_config("positive", foreground="green")
        text_box.see(END)
        text_box.update()

def create_md5(content):
    md = hashlib.md5()
    md.update(content)
    return bytes(md.hexdigest(), "utf-8")

def update():
    global text_box

def closing():
    main.destroy()
    sys.exit()

def button_action_handler(s):
    global text_box
    global b_delete
    global b_delete_all
    global b_restore
    global b_restore_all
    global b_add_file
    global li

    if s == "delete":
        tb = Thread(target=delete, args=(li.get(ACTIVE),0))
        tb.start()
    if s == "delete_all":
        tb = Thread(target=delete, args=(0,1))
        tb.start()
    if s == "restore":
        tb = Thread(target=restore, args=(li.get(ACTIVE),0))
        tb.start()
    if s == "restore_all":
        tb = Thread(target=restore, args=(0,1))
        tb.start()
    if s == "add_file":
        tb = Thread(target=add_file_to_quarantine)
        tb.start()
    if s == "details_button":
        tb = Thread(target=detailedReport)
        tb.start()
    if s == "scan_button":
        tb = Thread(target=scan)
        tb.start()
    if s == "update_button":
        tb = Thread(target=update)
        tb.start()
    if s == "quarantine_button":
        if li.winfo_viewable()  == 0:
            b_delete.place(x = 605, y = 61)
            b_delete_all.place(x = 605, y = 86)
            b_restore.place(x = 605, y = 111)
            b_restore_all.place(x = 605, y = 136)
            b_add_file.place(x = 605, y = 161)
            li.place(x = 605, y = 0)
            tb = Thread(target=quarantine)
            tb.start()
        if li.winfo_viewable() == 1:
            b_delete.place_forget()
            b_delete_all.place_forget()
            b_restore.place_forget()
            b_restore_all.place_forget()
            b_add_file.place_forget()
            li.place_forget()
    if s == "quit_button":
        tb = Thread(target=closing)
        tb.start()

def gui_thread():
    global main
    global update_button
    global scan_button
    global url_scan_button
    global url_scan_button
    global quit_button
    global text_box
    global li
    global b_delete
    global b_delete_all
    global b_restore
    global b_restore_all
    global b_add_file

    main = tkinter.Tk()
    main.title("MLAntiMalware")
    main.wm_iconbitmap("")
    main.geometry("800x192")
    main.resizable(False, False)
    hoehe = 2
    breite = 16

    scan_button = tkinter.Button(main,text = "Scan", command=lambda:button_action_handler("scan_button"), height = hoehe, width = breite)
    scan_button.grid(row = 0, column = 0)
    update_button = tkinter.Button(main,text = "Update", command=lambda:button_action_handler("update_button"), height = hoehe, width = breite)
    update_button.grid(row = 1, column = 0)
    quarantine_button = tkinter.Button(main,text = "Quarantine", command=lambda:button_action_handler("quarantine_button"), height = hoehe, width = breite)
    quarantine_button.grid(row = 3, column = 0)
    quit_button = tkinter.Button(main,text = "Close", command=lambda:button_action_handler("quit_button"), height = hoehe, width = breite)
    quit_button.grid(row = 4, column = 0, sticky="w")
    b_delete = tkinter.Button(main,text = "Remove current", height=0, width = 21, justify=CENTER)
    b_delete_all = tkinter.Button(main,text = "Remove all", height = 0, width = 21, justify=CENTER)
    b_restore = tkinter.Button(main,text = "Restore current", height=0, width = 21, justify=CENTER)
    b_restore_all = tkinter.Button(main,text = "Restore all", height = 0, width = 21, justify=CENTER)
    b_add_file = tkinter.Button(main,text = "Add file", height = 0, width = 21, justify=CENTER)
    b_delete.place(x = 605, y = 61)
    b_delete_all.place(x = 605, y = 86)
    b_restore.place(x = 605, y = 111)
    b_restore_all.place(x = 605, y = 136)
    b_add_file.place(x = 605, y = 161)
    b_delete.place_forget()
    b_delete_all.place_forget()
    b_restore.place_forget()
    b_restore_all.place_forget()
    b_add_file.place_forget()

    text_box = tkinter.scrolledtext.ScrolledText(main)
    text_box.place(height = 192, width = 454,x = 153, y = 0)

    li = tkinter.Listbox(main, height=3, width = 24)
    li.place(x = 605, y = 3)
    li.place_forget()

    text_box.insert(END, "Your System is Protected\n", "VIP")
    text_box.tag_config("VIP", background='yellow')
    text_box.insert(END, "[ + ] Preparing the program\n", 'positive')
    text_box.tag_config('positive', foreground='green')
    text_box.see(END)
    text_box.update()

    list_of_files = glob.glob(transfer)
    if(len(list_of_files)>0):
        latest_file = max(list_of_files, key=os.path.getctime)
        automatic_scan(latest_file)
    main.mainloop()

t_main = Thread(target=gui_thread)
t_main.start()
